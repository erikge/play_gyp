#!/usr/bin/env python
#
# Symbolicates an iOS crash dump file as generated by the OS or
# PLCrashReporter. Unlike the symbolicatecrash script shipped by Apple with
# Xcode, this script works with both Simulator and Device crash dumps. And it
# is faster.

import fileinput
import glob
import optparse
import os
import re
import subprocess
import sys

from bisect import bisect_left
from collections import defaultdict
from operator import itemgetter

_SYMBOLS_DIR_FORMAT = \
  '%s/Library/Developer/Xcode/iOS DeviceSupport/%s/Symbols*'
_XCODE_SYMBOLS_DIR_FORMAT = \
  '%s/Contents/Developer/Platforms/*.platform/DeviceSupport/%s/Symbols*'
_VIEWFINDER_DSYMS_PATH = \
  os.path.expanduser('~/Dropbox/viewfinder/dSYMS')
_VIEWFINDER_DSYMS_SUFFIX = \
  'Contents/Resources/DWARF/Viewfinder'
_VIEWFINDER_DSYMS_UUID_PATH = \
  os.path.expanduser('~/Dropbox/viewfinder/dSYMS.uuid')

kOSVersionRE = re.compile(r'\D*([0-9\.]+)(?:\s+\((?:Build )?(\w+)\))?')

kThreadTraceStartRE = re.compile(r'(?i)^thread \d+( crashed| name)?:.*$')


kBacktraceRE = re.compile(
    r'\s*(?P<frame_number>[0-9]+)\s+(?P<bundle_id>[-_a-zA-Z0-9\./]+)' +
    r'\s+(?P<address>0x[0-9A-Fa-f]+)\s+(?P<base>0x[0-9A-Fa-f]+)' )

kSymbolRE = re.compile(r'\s*\(in .*?\)\s*.*')
kHexadecimalNumRE = re.compile(r'0x[a-f0-9]+')

# uuid -> path (None indicating a path was not found)
uuid_cache = {}

class Symbolicator(object):
  def __init__(self):
    self.preamble_output = ''
    self.crashed_thread_backtrace_output = ''
    self.crashed_thread_title_output = ''
    self.backtrace_output = ''
    self.thread_state_output = ''
    self.binary_images_output = ''

  def FullOutput(self):
    return self.preamble_output + \
           self.crashed_thread_title_output + self.crashed_thread_backtrace_output + \
           self.backtrace_output + self.thread_state_output + self.binary_images_output

  def SummaryOutput(self):
    return self.preamble_output + \
           self.crashed_thread_title_output + self.crashed_thread_backtrace_output

  def OutputDict(self):
    return {'preamble': self.preamble_output,
            'crashed_thread_title': self.crashed_thread_title_output,
            'crashed_thread_backtrace': self.crashed_thread_backtrace_output,
            'backtrace': self.backtrace_output,
            'thread_state': self.thread_state_output,
            'binary_images': self.binary_images_output}

  @staticmethod
  def ReformatUuid(uuid):
    "Takes a plain-hex-number uuid, uppercases it, and inserts hyphens."
    uuid = uuid.upper()
    if len(uuid) == 36:
      # Already hyphenated.
      pass
    else:
      uuid = '-'.join([uuid[0:8], uuid[8:12], uuid[12:16], uuid[16:20], uuid[20:]])
    return uuid

  @staticmethod
  def FindSymbolsDirs(version, build):
    version_dirs = [ '%s (%s)' % (version, build), version, build ]
    library_dirs = [ "/System", "", os.path.expanduser("~") ]
    dirs = [ '' ]
    for l in library_dirs:
      for v in version_dirs:
        pat = _SYMBOLS_DIR_FORMAT % (l, v)
        dirs.extend(glob.glob(pat))

    mdfind = subprocess.Popen(
        ['mdfind', "kMDItemCFBundleIdentifier == 'com.apple.dt.Xcode' || " +
         "kMDItemCFBundleIdentifier == 'com.apple.Xcode'"],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    for line in mdfind.stdout:
      d = line.strip()
      for v in version_dirs:
        pat = _XCODE_SYMBOLS_DIR_FORMAT % (d, v)
        dirs.extend(glob.glob(pat))

    return dirs

  @staticmethod
  def FindBinaryImageByAddress(address):
    global addresses
    global binary_images
    index = bisect_left(addresses, int(address, 0))
    if index:
      return binary_images[index - 1]
    return None

  @staticmethod
  def FindPathByUuid(path, uuid, arch):
    def ViewfinderPath(uuid):
      p = os.path.join(_VIEWFINDER_DSYMS_UUID_PATH, uuid)
      if not os.path.exists(p):
        return None
      p = open(p).read().strip();
      if not p:
        return None
      return os.path.join(_VIEWFINDER_DSYMS_PATH, p, _VIEWFINDER_DSYMS_SUFFIX)

    def DsymForUuid(path, uuid, arch):
      dwarfdump = subprocess.Popen(
          ['dwarfdump', '--arch=%s' % arch, '--uuid', path],
          stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      for line in dwarfdump.stdout:
        if uuid in line:
          return ' '.join(line.strip().split(' ')[3:])
      return None

    try:
      p = uuid_cache[uuid]
    except KeyError:
      p = ViewfinderPath(uuid)

      if not p:
        mdfind = subprocess.Popen(
            ['mdfind', 'com_apple_xcode_dsym_uuids = ' + uuid],
            stdout=subprocess.PIPE)

        try:
          p = iter(mdfind.stdout).next()[:-1] # Strip \n
          if p.endswith(".xcarchive"):
            dsym_folder = os.path.join(p, "dSYMs")
            dsyms = glob.glob(os.path.join(p, "dSYMs/*.dSYM"))
            # I only know how to handle the case for one dsym. I'm sure there's a
            # way to figure out which we want for multiple-dsym xcarchives (if such
            # a thing exists?).
            if len(dsyms) == 1:
              p = os.path.join(p, "dSYMs", dsyms[0])
            else:
              p = None
        except StopIteration:
          p = None

        mdfind.wait()

      if p:
        # Translate the path to the dsym directory to the correct dsym file.
        p = DsymForUuid(p, uuid, arch)
      else:
        # Unable to find a dsym file, search through the symbol dirs looking for
        # an appropriately named library containing the desired uuid.
        global symbol_dirs
        for d in symbol_dirs:
          p = '%s/%s' % (d, path)
          if os.path.exists(p):
            p = DsymForUuid(p, uuid, arch)
            if p:
              break
          p = None

      uuid_cache[uuid] = p

    return p

  @staticmethod
  def LookupSymbols(path, arch, base, addresses):
    """using atos looks up symbols"""
    atos = subprocess.Popen(
        ['xcrun', 'atos', '-arch', arch, '-l', base, '-o', path ] + addresses,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    symbols = []
    for line in atos.stdout:
      symbols.append(kSymbolRE.sub('', line.strip()))
    return symbols

  def SymbolicateBacktraceLines(self, lines):
    # Invoking atos is expensive, so we minimize the calls by batching all of the
    # lookups for addresses associated with a particular path.
    path_to_addrs = defaultdict(dict)
    path_to_base = {}
    path_to_corrected_base = {}
    path_to_arch = {}

    for line in lines:
      match = kBacktraceRE.match(line)
      if not match:
        continue

      addr = match.group('address')
      base = match.group('base')

      image = Symbolicator.FindBinaryImageByAddress(addr)
      if not image:
        continue

      path = Symbolicator.FindPathByUuid(image[3], image[2], image[4])
      if not path:
        continue

      path_to_arch[path] = image[4]
      path_to_base[path] = base
      path_to_addrs[path][addr] = int(addr, 16) - int(image[0])

    addr_to_symbol = {}
    for (path, addrs) in path_to_addrs.items():
      corrected_addresses = addrs.values()
      addrs = addrs.keys()

      symbols = Symbolicator.LookupSymbols(
          path, path_to_arch[path], path_to_base[path], addrs)
      for i in xrange(0, len(addrs)):
        addr_to_symbol[addrs[i]] = (symbols[i], corrected_addresses[i])

    is_crashed_thread = False
    for line in lines:
      def _AppendLine(to_append):
        if is_crashed_thread:
          self.crashed_thread_backtrace_output += to_append
        else:
          self.backtrace_output += to_append

      stripped_line = line.strip()
      if kThreadTraceStartRE.match(stripped_line):
        is_crashed_thread = stripped_line.endswith('Crashed:')
        if is_crashed_thread:
          self.crashed_thread_title_output = line
          continue

      match = kBacktraceRE.match(line)
      if not match:
        _AppendLine(line)
        continue
      addr = match.group('address')
      symbol, corrected_address = addr_to_symbol.get(addr, ('unknown', 0))
      if kHexadecimalNumRE.match(symbol):
        # Replace address-only symbols by 'unknown'
        symbol = 'unknown'
      # To display addresses (corrected for random memory layout, display corrected_address.
      _AppendLine('%-30s %s\n' % (line[0:match.end('bundle_id')], symbol))

  @staticmethod
  def ParseOSVersion(line):
    match = kOSVersionRE.match(line)
    if not match:
      return None
    return (match.group(1), match.group(2))

  @staticmethod
  def ParseBinaryImageLine(line):
    elements = iter(line.split())
    start_address = elements.next()
    elements.next() # Hyphen
    end_address = elements.next()
    # The main(?) executable has plus sign before its bundle ID. Strip this off.
    bundle_id = elements.next().strip('+')
    arch = elements.next()
    uuid = Symbolicator.ReformatUuid(elements.next().strip('<>'))

    try:
      path = elements.next()
      try:
        while True:
          path += ' ' + elements.next()
      except StopIteration:
        pass
    except StopIteration:
      return (None, None, None)

    return (start_address, end_address, arch, bundle_id, uuid, path)

  def process_one_file(self, content_lines):
    global addresses
    global binary_images
    binary_images = []

    work = False
    is_in_backtrace = False
    is_in_thread_state = False
    is_in_binary_images = False
    backtrace_lines = []
    thread_state_lines = []
    binary_image_lines = []

    #assert False
    def flush_buffers():
      global binary_images
      global addresses
      binary_images = sorted(binary_images, key=itemgetter(0))
      addresses = [b[0] for b in binary_images]

      global symbol_dirs
      symbol_dirs = Symbolicator.FindSymbolsDirs(os_version, os_build)

      self.SymbolicateBacktraceLines(backtrace_lines)
      for line in thread_state_lines:
        self.thread_state_output += line
      for line in binary_image_lines:
        self.binary_images_output += line

      binary_images = []

    for line in content_lines:
      line_stripped = line.strip()
      if (line_stripped.startswith('Incident Identifier:') or
          line_stripped.startswith('Process:')):
        if is_in_binary_images:
          # End previous crash
          flush_buffers()
          is_in_binary_images = False

        # New crash
        work = True
        is_in_backtrace = is_in_thread_state = is_in_binary_images = False
        self.preamble_output += line
      elif not work:
        continue
      elif line_stripped.startswith('OS Version:'):
        os_version, os_build = Symbolicator.ParseOSVersion(line_stripped)
        self.preamble_output += line
      elif kThreadTraceStartRE.match(line_stripped):
        is_in_backtrace = True
        backtrace_lines.append(line)
      elif is_in_backtrace and ('Thread State' in line_stripped):
        is_in_backtrace = False
        is_in_thread_state = True
        thread_state_lines.append(line)
      elif line_stripped == 'Binary Images:':
        is_in_thread_state = False
        is_in_backtrace = False
        is_in_binary_images = True
        binary_image_lines.append(line)
      elif is_in_thread_state:
        thread_state_lines.append(line)
      elif is_in_backtrace:
        backtrace_lines.append(line)
      elif not is_in_binary_images:
        # We haven't gotten to backtrace or binary images yet. Pass this line
        # through.
        self.preamble_output += line
      elif is_in_binary_images:
        if line_stripped:
          binary_image_lines.append(line)
          start_address, end_address, arch, bundle_id, uuid, path = \
              Symbolicator.ParseBinaryImageLine(line_stripped)
          if bundle_id:
            binary_images.append((
                int(start_address, 0),
                int(end_address, 0),
                uuid, path, arch ))
        else:
          # End of crash
          flush_buffers()
          is_in_binary_images = False

    if is_in_binary_images:
      # Crash not followed by a newline
      flush_buffers()

def main(argv):
  parser = optparse.OptionParser(
    usage="%prog [options] [files]",
    description=\
"""Reads one or more crash logs from named files or standard input,
symbolicates them, and writes them to standard output.""",
    version='%prog 1.0.2 by Peter Hosey',
  )
  opts, args = parser.parse_args(argv[1:])
  for f in args:
    contents = open(f, 'r').readlines()
    sym = Symbolicator()
    sym.process_one_file(contents)
    sys.stdout.write(sym.FullOutput())


if __name__ == '__main__':
  main(sys.argv)
